Index: src/Balance.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.io.FileNotFoundException;\nimport java.util.*;\n\n/**\n * Effectively uses parsing and matrices to balance a chemical equation\n * Also contains the I/O\n */\npublic class Balance {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        try {\n            System.out.print(\"Please enter the chemical equation: \");\n            String equation = s.nextLine().replaceAll(\"\\\\s\", \"\");\n            System.out.println(\"Wish to continue? [Y/N]\");\n            String yn = s.nextLine().toUpperCase();\n            if (yn.equals(\"Y\")) {\n                String[] sides = equation.split(\"-->\");\n                String[] side1 = sides[0].split(\"\\\\+\");\n                String[] side2 = sides[1].split(\"\\\\+\");\n\n                for (int i = 0; i < side1.length; i++)\n                    side1[i] = FormulaParser.removeCoefficient(side1[i]);\n                for (int i = 0; i < side2.length; i++)\n                    side2[i] = FormulaParser.removeCoefficient(side2[i]);\n\n                ArrayList<String> s1 = new ArrayList<>(Arrays.asList(side1));\n                ArrayList<String> s2 = new ArrayList<>(Arrays.asList(side2));\n                LinearAlgebra solution = new LinearAlgebra(s1, s2);\n                System.out.println(\"\\nThe balanced equation is:\\n\");\n                solution.solve();\n\n            } else {\n                Date d = new Date();\n                System.out.printf(\"Logged out at: %tT%n\",d);\n                System.out.println();\n            }\n        } catch (ArrayIndexOutOfBoundsException | FileNotFoundException e) {\n            System.err.println(\"\\nTry again and enter a valid formula. Ensure the progression is \\\"-->\\\" not\" +\n                    \" \\\"--->\\\" and that extraneous symbols are not included.\\n\");\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Balance.java	(revision d50fdc4e026a69eedfa89d6c17ff3019b3c10818)
+++ src/Balance.java	(date 1586040997533)
@@ -14,7 +14,7 @@
             System.out.println("Wish to continue? [Y/N]");
             String yn = s.nextLine().toUpperCase();
             if (yn.equals("Y")) {
-                String[] sides = equation.split("-->");
+                String[] sides = equation.split("(-->)|(=)|(--->)|(->)");
                 String[] side1 = sides[0].split("\\+");
                 String[] side2 = sides[1].split("\\+");
 
Index: src/LinearAlgebra.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import org.apache.commons.math3.linear.*;\n\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * performs the solving of a matrix, determines solutions for coefficients\n */\npublic class LinearAlgebra {\n    private ArrayList<String> side1;\n    private ArrayList<String> side2;\n\n    /**\n     * the constructor\n     * @param s1 .\n     * @param s2 .\n     */\n    public LinearAlgebra (ArrayList<String> s1, ArrayList<String> s2) {\n        side1 = s1;\n        side2 = s2;\n    }\n\n    private ArrayList<String> t = new ArrayList<>();\n    private ArrayList<LinkedHashMap<String,Integer>> formulas = new ArrayList<>();\n\n    /**\n     * @return the matrix to be used\n     */\n    public double[][] getRawMatrix () {\n        t.addAll(side1); t.addAll(side2);\n        for (String s : t)\n            formulas.add(FormulaParser.parseFormula1(s));\n        ArrayList<String> arr = new ArrayList<>();\n        for (LinkedHashMap<String,Integer> a : formulas) {\n            for (Map.Entry<String,Integer> e : a.entrySet())\n                if (!arr.contains(e.getKey()))\n                    arr.add(e.getKey());\n        }\n        double[][] mat = new double[arr.size()][formulas.size()];\n        for (int row = 0; row < mat.length; row++) {\n            for (int col = 0; col < mat[0].length; col++) {\n                String el = arr.get(row);\n                mat[row][col] = formulas.get(col).get(el) == null ? 0 : formulas.get(col).get(el);\n            }\n        }\n        return mat;\n    }\n\n    /**\n     * Primary method to solve a matrix. Turns a rectangular matrix into a square one and takes leftover component\n     * as the constant vector. Thus, with N coefficients, N-1 solutions would be displayed with the fourth\n     * being det|A| where A is the square matrix\n     */\n    public void solve () throws FileNotFoundException {\n        double[][] mat = getRawMatrix();\n        int newLength = Math.min(mat.length, mat[0].length);\n        double[][] newMat = new double[newLength][newLength];\n        double[] cons = new double[mat.length];\n        for (int row = 0; row < newMat.length; row++) {\n            for (int col = 0; col < newMat[0].length; col++) {\n                newMat[row][col] = col > side1.size()-1 ? -mat[row][col] : mat[row][col];\n            }\n            cons[row] = mat[row][mat[0].length-1];\n        }\n        int count = 0;\n        for (int i = 0; i < newMat.length; i++) {\n            if (cons[i] == Math.abs(newMat[i][newMat[0].length-1]))\n                count++;\n        }\n        if (count == cons.length) {\n            for (int i = 0; i < newMat.length; i++) {\n                newMat[i][Math.max(mat.length,mat[0].length)-1] = 1;\n            }\n        }\n        RealMatrix coefficients = new Array2DRowRealMatrix(newMat,false);\n        RealVector constants = new ArrayRealVector(cons,false);\n        RealMatrix inverse = new LUDecomposition(coefficients).getSolver().getInverse();\n        RealMatrix inverseTimesDeterminant = inverse.scalarMultiply(new LUDecomposition(coefficients).getDeterminant());\n        RealVector ans = inverseTimesDeterminant.operate(constants);\n        double[] s = ans.toArray();\n        int[] sol = new int[s.length];\n        for (int i = 0; i < sol.length; i++)\n            sol[i] = (int) s[i];\n        ArrayList<Integer> arr = new ArrayList<>();\n        for (int i : sol)\n            arr.add(i);\n        arr.add((int) Math.abs(new LUDecomposition(coefficients).getDeterminant()));\n        simplify(arr);\n        for (int i = 0; i < t.size(); i++) {\n            System.err.print((arr.get(i) == 1 ? \"\" : arr.get(i)) +\"\"+t.get(i) +\n                    (i != side1.size()-1 ? (i == t.size()-1 ? \"\" : \" + \") : \" --> \"));\n        }\n        System.out.println();\n        PeriodicProperties.showProperties(formulas,t);\n    }\n\n    /**\n     * recursive algorithm to simplify answer vector\n     * @param arr is the solution vector\n     */\n    public void simplify (ArrayList<Integer> arr) {\n        int countEvens = 0;\n        for (int i = arr.size()-1; i >= 0; i--)\n            if (arr.get(i) == 0)\n                arr.remove(i);\n        for (int i : arr) {\n            if (i % 2 == 0) {\n                countEvens++;\n            }\n        }\n        for (int i = 0; i < arr.size(); i++)\n            arr.set(i,Math.abs(arr.get(i)));\n        if (countEvens == arr.size() ) {\n            for (int i = 0; i < arr.size(); i++)\n                arr.set(i,Math.abs(arr.get(i))/2);\n            simplify(arr);\n        }\n    }\n\n    /**\n     * For debugging purposes, printing a matrix\n     * @param mat a matrix\n     */\n    public void printMat (double[][] mat) {\n        for (double[] doubles : mat) {\n            for (int col = 0; col < mat[0].length; col++) {\n                System.out.print((int)doubles[col] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/LinearAlgebra.java	(revision d50fdc4e026a69eedfa89d6c17ff3019b3c10818)
+++ src/LinearAlgebra.java	(date 1586529232768)
@@ -1,5 +1,4 @@
 import org.apache.commons.math3.linear.*;
-
 import java.io.FileNotFoundException;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
@@ -89,10 +88,9 @@
         arr.add((int) Math.abs(new LUDecomposition(coefficients).getDeterminant()));
         simplify(arr);
         for (int i = 0; i < t.size(); i++) {
-            System.err.print((arr.get(i) == 1 ? "" : arr.get(i)) +""+t.get(i) +
-                    (i != side1.size()-1 ? (i == t.size()-1 ? "" : " + ") : " --> "));
+            System.out.print((arr.get(i) == 1 ? "" : arr.get(i)) +""+t.get(i) +
+                    (i != side1.size()-1 ? (i == t.size()-1 ? "" : " + ") : " --> ")+(i == t.size() - 1 ? "\n":""));
         }
-        System.out.println();
         PeriodicProperties.showProperties(formulas,t);
     }
 
@@ -112,7 +110,7 @@
         }
         for (int i = 0; i < arr.size(); i++)
             arr.set(i,Math.abs(arr.get(i)));
-        if (countEvens == arr.size() ) {
+        if (countEvens == arr.size()) {
             for (int i = 0; i < arr.size(); i++)
                 arr.set(i,Math.abs(arr.get(i))/2);
             simplify(arr);
Index: src/FormulaParser.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Class containing relevant methods to deal with chemical formulas\n */\npublic class FormulaParser {\n    /**\n     * @param formulas contains the formulas of one side of the equation\n     * @return a map with the merged values of each formula's map\n     */\n    public static LinkedHashMap<String,Integer> getSideAtoms (String[] formulas) {\n        ArrayList<LinkedHashMap<String,Integer>> arr = new ArrayList<>();\n        for (String formula : formulas) arr.add(parseFormula(formula));\n        LinkedHashMap<String,Integer> res = new LinkedHashMap<>();\n        for (LinkedHashMap<String,Integer> map : arr) {\n            map.forEach((k, v) -> res.merge(k, v, (key, val) -> v + val));\n        }\n        return res;\n    }\n\n    /**\n     * Uses stack algorithm\n     * @param formula is a chemical formula\n     * @return a map of each element and its frequency\n     */\n    public static LinkedHashMap<String, Integer> parseFormula(String formula) {\n        Pattern p = Pattern.compile(\"([A-Z][a-z]*)(\\\\d*)|(\\\\()|(\\\\))(\\\\d*)\");\n        Matcher m = p.matcher(removeCoefficient(formula)); //removes coefficients as input here\n        Stack<LinkedHashMap<String, Integer>> stack = new Stack();\n        stack.push(new LinkedHashMap<>());\n\n        int mx;\n        while (m.find()) {\n            String match = m.group();\n            if (match.equals(\"(\")) {\n                stack.push(new LinkedHashMap<>());\n            } else if (match.startsWith(\")\")) {\n                LinkedHashMap<String, Integer> top = stack.pop();\n                mx = match.length() > 1 ? Integer.parseInt(match.substring(1)) : 1;\n                for (String name: top.keySet()) {\n                    stack.peek().put(name, stack.peek().getOrDefault(name, 0) + top.get(name) * mx);\n                }\n            } else {\n                int i = 1;\n                while (i < match.length() && Character.isLowerCase(match.charAt(i))) {\n                    i++;\n                }\n                String name = match.substring(0, i);\n                mx = i < match.length() ? Integer.parseInt(match.substring(i)) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + mx);\n            }\n        }\n        return stack.peek();\n    }\n\n    /**\n     * secondary modified algorithm to aid in balancing with polyatomic ions\n     * @param formula a formula\n     * @return a element-frequency map\n     */\n    public static LinkedHashMap<String, Integer> parseFormula1(String formula) {\n        Pattern p = Pattern.compile(\"([A-Z][a-z]*)(\\\\d*)|(\\\\()|(\\\\))(\\\\d*)\");\n        Matcher m = p.matcher(removeCoefficient(formula)); //removes coefficients as input here\n        Stack<LinkedHashMap<String, Integer>> stack = new Stack();\n        stack.push(new LinkedHashMap<>());\n\n        int mx;\n        while (m.find()) {\n            String match = m.group();\n            if (match.equals(\"(\")) {\n                stack.push(new LinkedHashMap<>());\n            } else if (match.startsWith(\")\")) {\n                LinkedHashMap<String, Integer> top = stack.pop();\n                mx = match.length() > 1 ? Integer.parseInt(match.substring(1)) : 1;\n                stack.peek().put(formula.substring(formula.indexOf(\"(\")+1,formula.indexOf(\")\")),mx);\n            } else {\n                int i = 1;\n                while (i < match.length() && Character.isLowerCase(match.charAt(i))) {\n                    i++;\n                }\n                String name = match.substring(0, i);\n                mx = i < match.length() ? Integer.parseInt(match.substring(i)) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + mx);\n            }\n        }\n        return stack.peek();\n    }\n\n    /**\n     * to streamline balancing process\n     * @param formula a string formula\n     * @return the \"cleaned\" formula\n     */\n    public static String removeCoefficient (String formula) {\n        int i;\n        for (i = 0; i < formula.length(); i++)\n            if (!Character.isDigit(formula.charAt(i)))\n                break;\n        return formula.substring(i);\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/FormulaParser.java	(revision d50fdc4e026a69eedfa89d6c17ff3019b3c10818)
+++ src/FormulaParser.java	(date 1586618988168)
@@ -16,9 +16,8 @@
         ArrayList<LinkedHashMap<String,Integer>> arr = new ArrayList<>();
         for (String formula : formulas) arr.add(parseFormula(formula));
         LinkedHashMap<String,Integer> res = new LinkedHashMap<>();
-        for (LinkedHashMap<String,Integer> map : arr) {
+        for (LinkedHashMap<String,Integer> map : arr)
             map.forEach((k, v) -> res.merge(k, v, (key, val) -> v + val));
-        }
         return res;
     }
 
@@ -41,9 +40,8 @@
             } else if (match.startsWith(")")) {
                 LinkedHashMap<String, Integer> top = stack.pop();
                 mx = match.length() > 1 ? Integer.parseInt(match.substring(1)) : 1;
-                for (String name: top.keySet()) {
+                for (String name: top.keySet())
                     stack.peek().put(name, stack.peek().getOrDefault(name, 0) + top.get(name) * mx);
-                }
             } else {
                 int i = 1;
                 while (i < match.length() && Character.isLowerCase(match.charAt(i))) {
@@ -74,7 +72,6 @@
             if (match.equals("(")) {
                 stack.push(new LinkedHashMap<>());
             } else if (match.startsWith(")")) {
-                LinkedHashMap<String, Integer> top = stack.pop();
                 mx = match.length() > 1 ? Integer.parseInt(match.substring(1)) : 1;
                 stack.peek().put(formula.substring(formula.indexOf("(")+1,formula.indexOf(")")),mx);
             } else {
Index: src/PeriodicProperties.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class PeriodicProperties {\n    public static LinkedHashMap<String,Double> elementMasses = new LinkedHashMap<>();\n\n\n    public static void execute () throws FileNotFoundException {\n        Scanner in = new Scanner(new File(\"elements.csv\"));\n        String[] line;\n        while (in.hasNextLine()) {\n            line = in.nextLine().split(\",+\");\n            elementMasses.put(line[2],Double.parseDouble(line[3]));\n        }\n    }\n\n    public static void showProperties (ArrayList<LinkedHashMap<String,Integer>> formulas, ArrayList<String> names) throws FileNotFoundException {\n        execute();\n        double molarMass;\n        System.out.println();\n        for (int i = 0; i < formulas.size(); i++) {\n            molarMass = 0;\n            String str = names.get(i);\n            if (str.contains(\"(\")) {\n                int j;\n                for (j = 0; j < str.length(); j++) {\n                    if (str.charAt(j) == ')')\n                        break;\n                }\n                String polyatomic = str.substring(str.indexOf(\"(\")+1,str.indexOf(\")\"));\n                LinkedHashMap<String,Integer> poly = FormulaParser.parseFormula(polyatomic);\n                for (Map.Entry<String,Integer> e : poly.entrySet())\n                    e.setValue(e.getValue()*formulas.get(i).get(polyatomic));\n                formulas.get(i).remove(polyatomic);\n                int finalI = i;\n                poly.forEach((k, v) -> formulas.get(finalI).merge(k, v, (key, val) -> v + val));\n            }\n            for (Map.Entry<String,Integer> pair : formulas.get(i).entrySet()) {\n                molarMass += elementMasses.get(pair.getKey()) * pair.getValue();\n            }\n            System.out.print(\"Molar mass of \"+str+\" is \");\n            System.out.printf(\"%.3f\",molarMass);\n            System.out.print(\" g/mol\\n\");\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/PeriodicProperties.java	(revision d50fdc4e026a69eedfa89d6c17ff3019b3c10818)
+++ src/PeriodicProperties.java	(date 1585625006314)
@@ -8,7 +8,6 @@
 public class PeriodicProperties {
     public static LinkedHashMap<String,Double> elementMasses = new LinkedHashMap<>();
 
-
     public static void execute () throws FileNotFoundException {
         Scanner in = new Scanner(new File("elements.csv"));
         String[] line;
